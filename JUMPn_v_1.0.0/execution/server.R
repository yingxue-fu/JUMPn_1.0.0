############################################################
########### Directly Source Five Native Scripts ############
############################################################
source('JUMPn_Helpers/JUMPn_functions/wgcna_mod.R')       ##
source('JUMPn_Helpers/JUMPn_functions/JUMPn_rich.R')      ##
source('JUMPn_Helpers/JUMPn_functions/PPI_Analysis.R')    ##
source('JUMPn_Helpers/JUMPn_functions/Network_Analysis.R')##
source('JUMPn_Helpers/JUMPn_functions/JUMPn_Errors.R')    ##
source('JUMPn_Helpers/JUMPn_functions/JUMPn_UIs.R')       ##
source('JUMPn_Helpers/JUMPn_functions/JUMPn_Modals.R')   ##
############################################################
###################################################
###### Necessary Modules For JUMPn Execution ######
###################################################
library(shiny)                         ## Module 1
library(ggplot2)                       ## Module 2
library(DT)                            ## Module 3
library(tools)                         ## Module 4
library(tidyverse)                     ## Module 5
library(plyr)                          ## Module 6
library(writexl)                       ## Module 8
library(readxl)                        ## Module 9
library(igraph)                        ## Module 11
require(visNetwork, quietly = TRUE)    ## Module 12
library(ggnewscale)                    ## Module 13
library(WGCNA)                         ## Module 14
library(stringr)                       ## Module 15
library(annotate)                      ## Module 16
library(shinyjs)                       ## Module 17
library(shinyWidgets)

####################################################
####################################################
####################################################
############################
########## To Add ##########
############################
### 1) Upload Own Background 
### 2) Upload Own PPI Database
### 3) User-Defined Annotation Db
### 4) Annotation Db Selection 
### 5) Change Tab Titles 
### 6) Add Step-By-Step functionality 
### 7) Add modules w/o significant pathways to publication table
### 8) Improve style of publcation table

########################################################
#### Define the Server Logic For Execution of JUMPn ####
########################################################
server <- function(input, output,session) {
    observeEvent(input$ViewExampleFile2,{
        showModal(imageModal(output))
    })
    observeEvent(input$ViewExampleFile3,{
        showModal(imageModal2(output))
    })
    observeEvent(input$TransformInfo,{
        my_message <- 'By selecting "Yes", your expression data will be normalized by Log2 transformation. Normalizing expression data in this manner helps to limit the systematic variation between replicates.
        If you have not already normalized your data, we highly recommend making this parameter "YES" to improve co-expression cluster detection.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$FileTypeInfo,{
        my_message <- 'JUMPn currently supports .xlsx, .csv, and .txt input formats. Specifying the correct file type improves efficiency of reading the input. If you are not sure about
        features of the input file, click the "View Example File" button below.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$FileTypeInfo,{
        my_message <- 'JUMPn currently supports .xlsx, .csv, and .txt input formats. Specifying the correct file type improves efficiency of reading the input. If you are not sure about
        features of the input file, click the "View Example File" button below.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$UserFolderInfo,{
        my_message <- 'Data generated by JUMPn is already stored in a local folder termed Output_Locus. However, to ensure all of your data is saved, sspecify the name of the sub-directory
        within the Output_Locus folder where the data from this run will be sent'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$MinClusterInfo,{
        my_message <- 'This parameter represents how many genes/proteins must belong to the same expression profile in order to be treated like a co-expression cluster. Otherwise,
        this pseudo-cluster will be merged with a neighboring cluster provided it is within the minimum similarity threshold, or it will be dropped entirely.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$MinKMEInfo,{
        my_message <- 'In order to identify co-expression clusters, WGCNA uses a measure of similarity to assess the strength of relationship between the expression profiles of individual genes.
        In JUMPn, we use Pearson Correlation as the measure of similarity. If the similarity between expression profiles exceeds this threshold, these genes will be assigned to the same cluster. 
        This metric is applied iteratively to all genes.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$MinDistInfo,{
        my_message <- 'Some expression profiles will not have enough genes to exceed the minimum cluster size specified. If this profile does however exceed the Pearson correlaion threshold
        with a nearby cluster, then it can be merged with that cluster.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$SkipPPIInfo,{
        my_message <- 'With the addition of our step-by-step analysis which allows users to separately undertake WGCNA or PPI analysis, this function will be deprecated soon.
        If you wish to undertake a different type of analysis, we suggest navigating to the Change Analysis Mode button.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$TomSizeInfo,{
        my_message <- 'JUMPn uses two levels of PPI modularizattion, the first identifies disconnected components in the network, the second identifies areas of high density interactions 
        comparatively to the rest of the network. The minimum TOM module size actually reflects a maximum possible module size for the network. If a first level disconnected component exceeds this
        threshold, then it will undergo TOM-based modularization. For more information check out our most recent publication which can be found here:'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$BackgroundFileInfo,{
        my_message <- 'The gene background represents the pool of possible genes from which a set may be derived. For a pathway analysis result that better reflects your own dataset, you
        can provide your own background or merge your background with our in-house gene background.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$PPIFileInfo,{
        my_message <- 'In JUMPn, we built a composite PPI database from the BioPlex, STRING, and InWeb databases. If you wish, you can provide your own PPI database in .xlsx or .csv format. 
        It must be a two column data frame with a header.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$AnnotationFileInfo,{
        my_message <- 'As in the case of the PPI database, we also built a composite database for gene set annotation. Our composite database includes KEGG, GO, Reactome, and HALLMARK. If you wish
        to supply your own database or merge your database with ours, you may do so here. For precise examples of the annotation file format, please visit our HELP page.'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$BackgroundSelectInfo,{
        my_message <- 'Here you can select the default background, a user-supplied background, or merge backgrounds'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$AnnotationSelectInfo,{
        my_message <- 'Here you can select any combination of annotations'
        WidgetInfoModal(session,my_message)
    })
    observeEvent(input$SubmitNewSearch,{
        ConfirmNewSearchModal(session)
        observeEvent(input$ConfirmNewSearch,{
            closeSweetAlert()
            updateTabsetPanel(session, 'whichtab',selected='Home')
            updateTabsetPanel(session, 'whichtab',selected='Commence')
            hideTab('whichtab', target='WGCNAPage')
            hideTab('whichtab', target='PPIPage')
        })
        observeEvent(input$DownloadData,{
            closeSweetAlert()
            output$downloadData <- downloadHandler(
                filename = function() {
                    paste('JUMPn_Output_Data', ".zip", sep = "")
                },
                content = function(file) {
                    files2zip <- dir(output_directory, full.names = TRUE)
                    zip(zipfile=file, files=files2zip)    
                }
            )
        })
        observeEvent(input$CancelNewSearch, {
            closeSweetAlert()
        })
    })
    hideTab('whichtab', target='WGCNAPage')
    hideTab('whichtab', target='PPIPage')
    the_tab <- reactive({input$whichtab})
    # observeEvent(as.character(the_tab()),{
    #     print(the_tab())
    #     if (the_tab()=='Commence'){
    #         #showModal(inputModal3())
    #         testSweetAlert(session)
    #     }
    # })
    output$DynamicUI <- renderUI({
        Condensed_UI()
    })
    Data <- reactiveValues(
        Info = NULL
    )
    observeEvent(input$total_search, {
        ModeOfAnalysis <<- reactive("WGCNA+PPI")
        Data$Info <- "WGCNA+PPI"
    })
    observeEvent(input$WGCNASearch, {
        ModeOfAnalysis <<- reactive("Independent WGCNA")
        Data$Info <- "Independent WGCNA"    
    })
    observeEvent(input$PPISearch, {
        ModeOfAnalysis <<- reactive("Independent PPI")
        Data$Info <- "Independent PPI"
    })
    observeEvent(input$Advanced, {
        showModal(inputModal())
    })
    observeEvent(Data$Info,{
            print('one')
            withProgress(message="Processing User Input File", value=0, max=1.2, {
                pathway_datasets <- list(as.data.frame(read_xlsx('JUMPn_Helpers/database_dependencies/ComprehensivePathwayDatabases.xlsx', sheet='KEGG')),
                                         as.data.frame(read_xlsx('JUMPn_Helpers/database_dependencies/ComprehensivePathwayDatabases.xlsx', sheet='Reactome')),
                                         as.data.frame(read_xlsx('JUMPn_Helpers/database_dependencies/ComprehensivePathwayDatabases.xlsx', sheet='GO')),
                                         as.data.frame(read_xlsx('JUMPn_Helpers/database_dependencies/ComprehensivePathwayDatabases.xlsx', sheet='HALLMARK')) )
                pathway_vectorized_list <- list(strsplit(pathway_datasets[[1]][,2], '/'), strsplit(pathway_datasets[[2]][,2], '/'),
                                                strsplit(pathway_datasets[[3]][,2], '/'),strsplit(pathway_datasets[[4]][,2], '/'))
                background_file <- read.csv("JUMPn_Helpers/database_dependencies/hs_mm_background_v3.0_20170516.txt")
            #############################################################################################################################################
            #############################################################################################################################################
            ##################################################### Processing the User Input Params ######################################################
            #############################################################################################################################################
            #############################################################################################################################################
            if (ModeOfAnalysis()=='WGCNA+PPI' || ModeOfAnalysis()=='Independent WGCNA'){
            initial_time <- Sys.time()                                                                        ### Get Program Start Time
            project_wd <- getwd()                                                                             ### Store the Working Directory
            input_file <- input$input_table                                                                   ### Store the User's Data File          
            input_file <- input_file$datapath                                                                 ### Acquire the Path to the User Input File
            null_error_handle(input_file,'Please Upload A Data File')
            extension <- file_ext(input_file)
            if (extension == 'xlsx'){                                                                            ### If the User File is .xlsx ...
                table <- read_excel(input_file, na='NA')                                                               ### Call read_excel function on the user input file
            } else if (extension == 'csv'){                                                                     ### If the User file is .csv  ...
                table <- read.csv(input_file)                                                               ### Also call read_excel function
            } else if (extension == 'txt'){                                                                     ### If the User file is ,txt
                table <- read.table(input_file)                                                               ### Call base r read.table function
            }                                                                                                 ### Read the user's file no matter the type
            gene_names <- table[,2]                                                                           ### Collect the gene names, which will always be in column 2 
            input_data_frame <- data.frame(GN=gene_names)                                                     
            expression_data <- table[,4:ncol(table)]
            expression_title <- colnames(expression_data)
            input_data_frame <- cbind(input_data_frame, expression_data)
            column_name_list <- c('Gene Names')
            for (replicate in 1:(ncol(table)-4)){
                replicate_name <- sprintf('%d', replicate)
                column_name_list <- c(column_name_list, replicate_name)
            }
            colnames(input_data_frame) <- column_name_list
            
            incProgress(message = "Normalizing TMT Data", .1)
            GN <- input_data_frame[,1]
            #typeof_error_handle(GN[1],'character','Non-Character Data Where Gene List Should Be. Fix Input File Format')
            normalized_TMT_df <- data.frame(GN)
            input_expression_data <- as.data.frame(input_data_frame[,2:ncol(input_data_frame)])
            input_expression_data[is.na(input_expression_data)] <- 0
            #for (col in 1:ncol(input_expression_data)){
                #input_expression_data[,col] <- 
                #typeof_error_handle(input_expression_data[,col][[1]],'double','Non-Numeric Data Where Expression Data Should Be. Fix Input File Format')
            #}
            if (input$transformation == 1)  transformed <- log2(input_expression_data)
            else transformed <- input_expression_data
            normalized_TMT_df <- cbind(normalized_TMT_df, transformed)
            target_folder <- input$UserFolder
            if (is.element('Output_Locus', list.files(project_wd))==FALSE){
                dir.create(sprintf('%s/Output_Locus', project_wd))
            }
            if (is.element(target_folder, list.files(sprintf('%s/Output_Locus',project_wd)))==TRUE){
                unlink(sprintf('%s/Output_Locus/%s', project_wd,target_folder), recursive = TRUE)
            }
            target_folder <- sprintf('Output_Locus/%s',target_folder)
            dir.create(sprintf('%s/%s', project_wd, target_folder))
            write.csv(normalized_TMT_df, file=paste(target_folder, "/norm_exp_matrix.csv", sep=''), quote=T,row.names=F,sep="\t")
            #############################################################################################################################################
            #############################################################################################################################################
            #############################################################################################################################################
            #############################################################################################################################################
            
            #############################################################################################################################################
            #############################################################################################################################################
            ##################################################### Execute Co-Expression Clustering ######################################################
            #################################################################### WGCNA ##################################################################
            #############################################################################################################################################
            incProgress(message='Executing WGCNA Clustering', .1)
            min_cluster_size <- input$min_cluster_size
            min_cluster_dist <- input$min_cluster_dist
            min_kME <- input$min_kme
            network_type <- 'signed'
            scale_free_R_sq <- .8
            non_scale_free_beta <- 16
            cluster_file_list <- c()
            cluster_name_list <- c()
            enrichment_list <- list()
            execute_WGCNA <- 'Yes'
            wgcna_directory <- sprintf('%s/%s/wgcna_output',project_wd,target_folder)
            dir.create(sprintf('%s/%s/wgcna_output',project_wd,target_folder))
            pre_wgcna <- Sys.time()
            execute_wgcna(input_exp_matrix = sprintf('%s/norm_exp_matrix.csv',target_folder), col_offset = 1, min_cluster_size = sprintf('%.2f',min_cluster_size), min_cluster_dist = sprintf('%.2f',min_cluster_dist),  min_kME=sprintf('%.2f',min_kME), network_type=sprintf('%s',network_type), scale_free_R_sq=sprintf('%.2f',scale_free_R_sq), non_scale_free_beta=16, outputDir=sprintf('%s',wgcna_directory))
            post_wgcna <- Sys.time()
            file_list <- list.files(path=(sprintf('%s', wgcna_directory)))
            for (item in file_list){ 
                if (substr(item, 1, 7)=='Cluster'){
                    cluster_file_list <- c(cluster_file_list, item)
                }
            }
            #############################################################################################################################################
            #############################################################################################################################################
            #############################################################################################################################################
            #############################################################################################################################################
            
            #############################################################################################################################################
            #############################################################################################################################################
            ##################################################### Cluster Based Pathway Enrichment ######################################################
            #############################################################################################################################################
            #############################################################################################################################################
            
            cluster_dt_meta <- list()
            meta_ctr <- 1
            clust_ct <- 1
            cluster_specific_table_list <- list()
            dfs_for_heatmaps <- list()
            cluster_pathway_list <- list()
            cluster_specific_group_plot <- list()
            clustered_df_list <- list()
            pre_cluster_pathway_analysis <- Sys.time()
            KEGG_list <- list()
            Reactome_List <- list()
            GO_List <- list() 
            HALLMARK_List <- list()
            for (file in cluster_file_list){
                search_file <- sprintf("%s/%s", wgcna_directory, file)
                cluster_data <- read.table(search_file, sep = '\t', header=TRUE)
                enrichment_list <- c(enrichment_list, unique(cluster_data[1])) # GN list by combining all clusters; question: is this one list? Or is it N list, one for each cluster? It appears it's N list, one for each cluster!
                cluster_genes <- toupper(unlist(unique(cluster_data[,1])))
                pre_time <- Sys.time()
                grouped_pathways <- pathway_enrichment2(pathway_datasets,pathway_vectorized_list, background_file,cluster_genes,5)
                if (!is.null(grouped_pathways)==TRUE){
                    if (!is.null(grouped_pathways[[1]])==TRUE ){
                      if(nrow(grouped_pathways[[1]])>0){
                        grouped_pathway_for_export <- grouped_pathways[[1]]
                        cluster_pathway_list[[clust_ct]] <- cbind(Cluster=sprintf('Cluster %d', clust_ct),grouped_pathway_for_export)
                      }
                    } 
                    if (!is.null(grouped_pathways[[2]])==TRUE){
                      if(nrow(grouped_pathways[[2]])>0){
                        grouped_pathway_for_heatmap <- cbind(Cluster=sprintf('Cluster %d', clust_ct),grouped_pathways[[2]])
                        dfs_for_heatmaps[[clust_ct]] <- grouped_pathway_for_heatmap
                        meta_ctr <- meta_ctr + 1
                      }
                    }
                    if (!is.null(grouped_pathways[[3]])==TRUE){
                      grouped_data_list <- grouped_pathways[[3]]
                      if (length(grouped_data_list)>0){KEGG_list[[clust_ct]] <- cbind(Cluster=sprintf('Cluster %d', clust_ct),Database='KEGG', grouped_data_list[[1]])}
                      if (length(grouped_data_list)>1){Reactome_List[[clust_ct]] <- cbind(Cluster=sprintf('Cluster %d', clust_ct), Database='Reactome',grouped_data_list[[2]])}
                      if (length(grouped_data_list)>2){GO_List[[clust_ct]] <- cbind(Cluster=sprintf('Cluster %d', clust_ct),Database='GO',grouped_data_list[[3]])}
                      if (length(grouped_data_list)>3){HALLMARK_List[[clust_ct]] <- cbind(Cluster=sprintf('Cluster %d', clust_ct),Database='HALLMARK',grouped_data_list[[4]])}
                      group_specific_data <- group_specific_enrichment(grouped_pathways[[3]],wgcna_directory,sprintf('Cluster%d', clust_ct))
                      cluster_specific_table_list[[clust_ct]] <- group_specific_data[[2]]
                      cluster_specific_group_plot[[clust_ct]] <- group_specific_data[[1]]
                    }
                }
                table_df <- as.data.frame(table)
                df_subset <- table_df[is.element(toupper(unlist(table_df[,2])),cluster_genes)==TRUE,]
                cluster_dt_meta[[clust_ct]] <- cbind(Cluster=sprintf('Cluster %d', clust_ct),df_subset)
                clust_ct <- clust_ct + 1
            }  
            cluster_title_list <- c()
            for (n in 1:(clust_ct-1)){
              item <- sprintf('Cluster %d', n)
              cluster_title_list <- c(cluster_title_list, item)
            }
            n_clusters <- length(cluster_title_list)
            dfs_list  <- list(do.call(rbind, KEGG_list),do.call(rbind, Reactome_List),do.call(rbind, GO_List),do.call(rbind, HALLMARK_List))
            total_cluster_pathway_dataframe <- do.call(rbind,dfs_list)
            total_pathway_df <- do.call(rbind,cluster_dt_meta)
            total_cluster_pathway_df <- do.call(rbind,clustered_df_list)
            total_cluster_df <- as.data.frame(do.call(rbind,cluster_dt_meta))
            combined_cluster_pathway_table <- as.data.frame(do.call(rbind,cluster_pathway_list))
            heatmap_df <- do.call(rbind,dfs_for_heatmaps)
            pathway_heatmap(na.omit(heatmap_df),wgcna_directory,n_clusters)
            heat_file <- sprintf("%s/FDR_heatmap.png", wgcna_directory)
            #############################################################################################################################################
            #############################################################################################################################################
            #############################################################################################################################################
            #############################################################################################################################################
            write_xlsx(total_pathway_df[,1:3],sprintf('%s/WGCNA_3Column_Summary.xlsx',wgcna_directory))

            ###################################################################################################################################################
            ###################################################################################################################################################
            ################################################### Construct Co-Expression Output Objects ########################################################
            ###################################################################################################################################################
            ###################################################################################################################################################
            post_cluster_pathway_analysis <- Sys.time()
            output$ClusterDTSelectionBox <- renderUI({
                selectInput('ClusterDTSelect', h5("Select the Cluster You'd Like to Display"),
                            choices = cluster_title_list,
                            selected = 'Cluster 1')
            })
            output$DynamicClusterDTDisplay <- renderUI({
                alpha2 <- dataTableOutput('ClusterDT')
                cluster_content_beta <- list(alpha2)
                do.call(tagList, cluster_content_beta)
            })
            observeEvent(input$ClusterDTSelect, {
                cluster <- input$ClusterDTSelect
                #cluster_pathway_table <- total_cluster_pathway_df[total_cluster_pathway_df[,1]==cluster,]
                title_1 <- sprintf("Table 1. Co-Expression Cluster %s Total Enriched Pathways Ranked", cluster)
                css <- sprintf('<p style="font-size:30px">%s </p>', title_1)
                output$ClusterPathwayTableTitle <- renderText(css)
                cluster_pathway_table <- as.data.frame(combined_cluster_pathway_table[combined_cluster_pathway_table[,1]==cluster,])
                cluster_pathway_table[,4] <- formatC(as.vector(unlist(cluster_pathway_table[,4])), format = 'e',digits=2)
                cluster_pathway_table[,5] <- formatC(as.vector(unlist(cluster_pathway_table[,5])), format = 'e',digits=2)
                output$ClusterPathwayTable <- renderDataTable({
                  DT::datatable(cluster_pathway_table,options = list(pageLength=10), rownames=FALSE)
                })
                i <- match(cluster,cluster_title_list)
                dt <- cluster_dt_meta[[i]]
                dt <- dt[,2:ncol(dt)]
                dt[,4:ncol(dt)] <- round(dt[,4:ncol(dt)],2)
                dt <- as.data.frame(dt)
                output$ClusterDT <- renderDataTable({
                    DT::datatable(dt, options = list(pageLength=5))
                })
                observeEvent(input$ClusterDT_cell_clicked, {
                    selection <- input$ClusterDT_cell_clicked    
                    row_clicked <- selection$row
                    if (is.null(row_clicked)==FALSE){
                        gene <- dt[row_clicked,2]
                        expression_data <- dt[row_clicked,4:ncol(table)]
                    } else {
                        gene <- dt[1,2]
                        expression_data <- dt[1,4:ncol(table)]
                    }
                    mean_vector <- (colMeans(dt[,4:ncol(dt)]))^10
                    expression_labels <- colnames(dt[,4:ncol(dt)])
                    expression_data <- expression_data^10
                    df <- data.frame(labels=expression_title)
                    df <- cbind(df, value=as.vector(unlist(expression_data)))
                    colnames(df) <- c('Label', 'Expression')
                    df$Label <- factor(df$Label, levels = df$Label)
                    df2 <- data.frame(labels=expression_title)
                    df2 <- cbind(df2, value=as.vector(unlist(mean_vector)))
                    colnames(df2) <- c('Label', 'Expression')
                    df2$Label <- factor(df2$Label, levels = df2$Label)
                    min <- min(expression_data)
                    max <- max(expression_data)
                    mean_min <- min(mean_vector) - (min(mean_vector)*.1)
                    mean_max <- max(mean_vector)
                    lower_range <- min - (min*.1)
                    upper_range <- max + (max*.01)
                    mid <- (lower_range+upper_range)/2
                    title <- sprintf('Figure 4. %s: %s Expression Profile',cluster,gene)
                    cluster_title <- sprintf('Figure 5. %s Average Expression Profile',cluster)
                    fluidRow(
                        column(6,
                            output$GeneExpression <- renderPlot({
                                ggplot(data=df) + 
                                    geom_col(aes(x=Label, y=Expression, fill=Expression)) +
                                    coord_cartesian(ylim=c(lower_range,upper_range)) + 
                                    ggtitle(title) + 
                                    xlab('Expression Replicates') + 
                                    ylab('Intensity') + 
                                    scale_color_continuous(low="red", high="green") + 
                                    theme(plot.title = element_text(size=15, face='bold', hjust=0.5),
                                          axis.title.x = element_text(face='bold',size=14),
                                          axis.title.y = element_text(face='bold',size=14),
                                          panel.border = element_rect(colour = "black", fill=NA, size=2),
                                          axis.text.x=element_text(angle=45,hjust=1, vjust=1))
                                ggsave(sprintf('%s/Cluster%d_%s_ExpressionProfile.pdf',wgcna_directory,i,gene))
                            })),
                        
                        column(6,
                            output$Cluster_Expression <- renderPlot({
                                ggplot(data=df2) + 
                                    geom_col(aes(x=Label, y=Expression, fill=Expression)) +
                                    coord_cartesian(ylim=c(mean_min,mean_max)) + 
                                    ggtitle(cluster_title) + 
                                    xlab('Expression Replicates') + 
                                    ylab('Intensity') + 
                                    scale_color_continuous(low="red", high="green") + 
                                    theme(plot.title = element_text(size=15, face='bold', hjust=0.5),
                                          axis.title.x = element_text(face='bold',size=14),
                                          axis.title.y = element_text(face='bold',size=14),
                                          panel.border = element_rect(colour = "black", fill=NA, size=2),
                                          axis.text.x=element_text(angle=45,hjust=1,vjust=1))
                                ggsave(sprintf('%s/Cluster%d_ExpressionProfile.pdf',wgcna_directory,i))
                            })),
                    )
                    
                })
            })
            observeEvent(input$ExpressionDisplay, { 
                if (input$ExpressionDisplay=='Trends'){
                    output$ExpressionDisplayObject <- renderUI({
                        main_title <- htmlOutput("TrendTitle")
                        main_plot <- imageOutput("TrendPlot")
                        trend_content <- list(main_title, main_plot)
                        do.call(tagList, trend_content)
                    })
                    title1 <- "Figure 3. WGCNA Co-Expression Cluster Trends"
                    css1 <- sprintf('<p style="font-size:30px">\t%s</p>', title1)
                    output[['TrendTitle']] <- renderText(css1)
                    trend_file <- sprintf("%s/trends_coexpression_cluster.png", wgcna_directory)
                    output[['TrendPlot']] <- renderImage({
                        outfile <- tempfile(fileext='.png')
                        png(outfile, width=450, height=500)
                        dev.off()
                        list(src = trend_file,
                             contentType = 'image/png',
                             width = 450,
                             height = 500,
                             alt = "This is alternate text")
                    }, deleteFile=FALSE)
                } else if (input$ExpressionDisplay=='Boxplot') {
                    output$ExpressionDisplayObject <- renderUI({
                        main_title <- htmlOutput("BoxplotTitle")
                        main_plot <- imageOutput("Boxplot")
                        trend_content <- list(main_title, main_plot)
                        do.call(tagList, trend_content)
                    })
                    title2 <- "Figure 1. Boxplot Co-Expression Clusters"
                    css2 <- sprintf('<p style="font-size:30px">\t%s</p>', title2)
                    output[['BoxplotTitle']] <- renderText(css2)
                    boxplot_file <- sprintf('%s/boxplot_coexpression_cluster.png', wgcna_directory)
                    output[['Boxplot']] <- renderImage({
                        outfile <- tempfile(fileext='.png')
                        png(outfile, width=450, height=500)
                        dev.off()
                        list(src = boxplot_file,
                             contentType = 'image/png',
                             width = 450,
                             height = 500,
                             alt = "This is alternate text")
                    }, deleteFile=FALSE)
                }
                
            }) 
            #############################################################################################################################################
            #############################################################################################################################################
            ####################################################### Cluster Based Pathway Heatmap #######################################################
            #############################################################################################################################################
            #############################################################################################################################################
            output$ClusterPathwayHeatmap <- renderUI({
                alpha <- htmlOutput('HeatTitle')
                beta <- imageOutput('HeatImage')
                heat_content <- list(alpha,beta)
                do.call(tagList,heat_content)
            })
            title3 <- "Figure 2. Cluster Pathway Enrichment Heatmap"
            css3 <- sprintf('<p style="font-size:30px">\t%s</p>', title3)
            output[['HeatTitle']] <- renderText(css3)
            output[['HeatImage']] <- renderImage({
                outfile <- tempfile(fileext='.png')
                png(outfile, width=450, height=500)
                dev.off()
                list(src = heat_file,
                     contentType = 'image/png',
                     width = 450,
                     height = 500,
                     alt = "This is alternate text")
            }, deleteFile=FALSE)
            }
            #############################################################################################################################################
            #############################################################################################################################################
            #############################################################################################################################################
            #############################################################################################################################################
            ###################################################################################################################################################
            ###################################################################################################################################################
            ###################################################################################################################################################
            ###################################################################################################################################################
            
                
                
            #############################################################################################################################################
            #############################################################################################################################################
            ######################################################## Protein Interacton Analysis ########################################################
            #############################################################################################################################################
            #############################################################################################################################################
            if (ModeOfAnalysis()=='WGCNA+PPI' || ModeOfAnalysis()=='Independent PPI'){
            modular_content_list <- list()
            modular_content_names <- c()
            modular_content_list_ctr <- 1
            cluster_content_list  <- list()
            cluster_content_names <- c()
            cluster_content_list_ctr <- 1
            incProgress(message='Accessing Protein Interaction Data', .1)
              incProgress(message="Overlaying Protein Interaction Network (This May Take A Few Minutes)", .1)
              pre_ppi_analysis <- Sys.time()
              ppi_content <- read.table('JUMPn_Helpers/database_dependencies/BioPlex_String400_Inweb150_v1.0.1.sif', header=TRUE, colClasses= c(NA, "NULL", NA))
              combined_df_list <- list()
              
              if (ModeOfAnalysis()=='WGCNA+PPI'){
                  upper_combined_gene_list <- toupper(unique(unlist(enrichment_list))) # GN list by combining all clusters
                  interaction_cluster <- ppi_content[((is.element(ppi_content[,1],upper_combined_gene_list)==TRUE) & (is.element(ppi_content[,2],upper_combined_gene_list)==TRUE) & (ppi_content[,1]!=ppi_content[,2])),] # subnetwork by overlaying cluster genes onto the PPI net
                  for (cluster in 1:length(enrichment_list)){ # loop for each cluster: get edges within each WPC (stored in 'combined_df_list')
                      combined_df_list[[cluster]] <- interaction_cluster[((is.element(interaction_cluster[,1],toupper(enrichment_list[[cluster]]))==TRUE) & (is.element(interaction_cluster[,2],toupper(enrichment_list[[cluster]]))==TRUE) ),]
                  }
              } else if (ModeOfAnalysis()=='Independent PPI'){
                  project_wd <- getwd() 
                  target_folder <- input$UserFolder
                  if (is.element('Output_Locus', list.files(project_wd))==FALSE){
                      dir.create(sprintf('%s/Output_Locus', project_wd))
                  }
                  print('yes')
                  if (is.element(target_folder, list.files(sprintf('%s/Output_Locus',project_wd)))==TRUE){
                      unlink(sprintf('%s/Output_Locus/%s', project_wd,target_folder), recursive = TRUE)
                  }
                  print('no')
                  target_folder <- sprintf('Output_Locus/%s',target_folder)
                  dir.create(sprintf('%s/%s', project_wd, target_folder))
                  ppi_file <- input$input_table
                  file_type <- file_ext(ppi_file$datapath)
                  print(file_type)
                  if (file_type=='xlsx'){
                      ppi_stuff <- read_xlsx(ppi_file$datapath)
                      clusters <- unique(unlist(ppi_stuff[,1]))
                      for (cluster in 1:length(clusters)){
                          enrichment_list <- toupper(unique(unlist(ppi_stuff[ppi_stuff[,1]==clusters[cluster],3])))
                          combined_df_list[[cluster]] <-  ppi_content[((is.element(ppi_content[,1],enrichment_list)==TRUE) & (is.element(ppi_content[,2],enrichment_list)==TRUE) & (ppi_content[,1]!=ppi_content[,2])),] # subnetwork by overlaying cluster genes onto the PPI net
                      }
                  }
              }
              print('here')
              nodular_dataframe_list <- list()
              total_cluster_ctr <- 1
              interaction_clusters <- list()
              modularization_folder <- 'ppi_modularization_output'
              dir.create(sprintf('%s/%s/%s',project_wd,target_folder,modularization_folder))
              for (cluster in combined_df_list){ # loop for each cluster: 
                  print(sprintf('Cluster %d', total_cluster_ctr))
                  data <- PPI_Modularization(cluster,10,total_cluster_ctr,project_wd,target_folder)
                  if (is.null(data)==FALSE){
                      if  (is.null(data[[1]])==FALSE){
                          if (is.null(data[[2]])==FALSE){
                             nodular_dataframe_list[[total_cluster_ctr]] <- data[[1]]
                             interaction_clusters[[total_cluster_ctr]] <- data[[2]]
                             total_cluster_ctr <- total_cluster_ctr + 1
                          }
                      }
                  }
              }
              print('there')
              #############################################################################################################################################
              #############################################################################################################################################
              #############################################################################################################################################
              #############################################################################################################################################
              
              
              post_ppi_analysis <- Sys.time()
              ###################################################################################################################################################
              ###################################################################################################################################################
              ################################################### Develop Comprehensive Network Objects #########################################################
              ###################################################################################################################################################
              ###################################################################################################################################################
              incProgress(message="Generating Total Network", .1)
              edge_frame_list <- list()
              network_data <- do.call(rbind, nodular_dataframe_list)              ##
              nodular_meta_data <- as.data.frame(network_data[,1:5])
              colnames(nodular_meta_data) = c('id', 'label','group','shape','color')
              final_node_frame <- nodular_meta_data[!duplicated(nodular_meta_data[,1]),]
              edge_meta_data <- do.call(rbind, interaction_clusters)
              check_list <- unlist(nodular_meta_data[,1]) 
              rownames(edge_meta_data) <- c(1:nrow((edge_meta_data)))                        ##
              colnames(edge_meta_data) <- c('from', 'to')  
              final_edge_frame <- edge_meta_data[((is.element(edge_meta_data[,'from'],check_list)==TRUE) & (is.element(edge_meta_data[,2],check_list)==TRUE) ),]
              final_edge_frame <- cbind(final_edge_frame, weights=1)
              final_edge_frame <- cbind(final_edge_frame, color='black')
              ###################################################################################################################################################
              ###################################################################################################################################################
              ###################################################################################################################################################
              ###################################################################################################################################################
    
              ###################################################################################################################################################
              ###################################################################################################################################################
              #################################################### Develop Modularized Network Objects ##########################################################
              ###################################################################################################################################################
              ###################################################################################################################################################
              incProgress(message="Creating Modularized Networks", .1)
              directory <- sprintf('%s/%s/network_models',project_wd,target_folder)
              dir.create(sprintf('%s/%s/network_models',project_wd,target_folder))
              net_file <- 'total_network.html'
              nodular_frame_list <- list() 
              modular_pathway_plot_list <- list()
              group_specific_table_list <- list()
              second_pathway_list_ctr <- 1
              modules_used <- c()
              edge_weight_list <- list()
              modular_list_ctr <- 1
              pathway_list_ctr <- 1
              pathway_df_list <- list()
              modularized_gene_list <- list()
              nod_ctr  <- 1
              cluster_modules <- list()
              cluster_module_ctr <- 1
              pre_modular_pathway_analysis <- Sys.time()
              total_modular_groups <- c()
              for(i in 1:length(nodular_dataframe_list)){
                  if (!is.null(nodular_dataframe_list[[i]])==TRUE){
                      data_x <- Derive_Edge_Weights(nodular_dataframe_list[[i]],interaction_clusters[[i]])
                      edge_frame_list[[nod_ctr]] <- as.data.frame(data_x[[1]])
                      edge_weight_list[[nod_ctr]] <- as.vector(data_x[[2]])
                      nod_ctr <- nod_ctr + 1
                      the_groups  <- as.vector(data_x[[4]])
                      cluster_modules[[cluster_module_ctr]] <- the_groups
                      cluster_module_ctr <- cluster_module_ctr + 1
                      total_modular_groups <- c(total_modular_groups, the_groups)
                      incProgress(message="Identifying Enriched Ontologies", .1)
                      for (module in 1:length(the_groups)){
                          gene_set <- unlist(data_x[[3]][data_x[[3]][,3]==the_groups[module],1])
                          modularized_gene_list[[modular_list_ctr]] <- gene_set
                          if (length(gene_set)>2){
                            cluster_pathway_table <- pathway_enrichment2(pathway_datasets,pathway_vectorized_list,background_file,gene_set,0)
                          } else {
                            cluster_pathway_table <- NULL
                          }
                          if (!is.null(cluster_pathway_table[[1]])==TRUE ){
                            if(nrow(cluster_pathway_table[[1]])>0){
                              grouped_pathway_for_export <- cluster_pathway_table[[1]]
                              if (ModeOfAnalysis()=='WGCNA+PPI'){
                                cluster_pathway_list[[clust_ct]] <- cbind(Cluster=sprintf('Cluster %d', modular_list_ctr),grouped_pathway_for_export)
                              }
                            }
                          } 
                          if (!is.null(cluster_pathway_table[[2]])==TRUE){
                            if(nrow(cluster_pathway_table[[2]])>0){
                              grouped_pathway_for_heatmap <- cbind(Module=the_groups[module],cluster_pathway_table[[2]])
                              pathway_df_list[[pathway_list_ctr]] <- grouped_pathway_for_heatmap
                              pathway_list_ctr <- pathway_list_ctr + 1
                            }
                          }
                          if (!is.null(cluster_pathway_table[[3]])==TRUE){
                            group_specific_data <- group_specific_enrichment(cluster_pathway_table[[3]],directory,the_groups[module])
                            group_specific_plot_beta <- group_specific_data[[1]]
                            modular_pathway_plot_list[[second_pathway_list_ctr]] <- group_specific_plot_beta
                            group_specific_table_list[[second_pathway_list_ctr]] <- group_specific_data[[2]]
                            module_heatmap(gene_set,group_specific_data[[2]],directory,the_groups[module])
                            modules_used <- c(modules_used,the_groups[module])
                            second_pathway_list_ctr <- second_pathway_list_ctr + 1
                          }
                          modular_list_ctr <- modular_list_ctr + 1
                      }
                  }
              }
              names(modularized_gene_list) <- total_modular_groups
              post_modular_pathway_analysis <- Sys.time()
              cluster_object_list <- list()
              for (i in 1:length(nodular_dataframe_list)){
                object <- sprintf('Cluster %d', i)
                cluster_object_list[[i]] <- object
              }
              total_modules <- as.vector(unlist(cluster_modules))
              pathway_total_df <- do.call(rbind, pathway_df_list)
              modules <- unique(pathway_total_df[,1])
              lengths <- unique(pathway_total_df[,7])
              module_gene_set <- c()
              condensed_list <- c()
              size_vector <- c()
              for (module in 1:length(total_modules)){
                  the_mod <- total_modules[module]
                  if (the_mod %in% modules){
                      pathways <- unlist(pathway_total_df[pathway_total_df[,1]==the_mod,2])
                      if (length(pathways) > 10){
                          pathways <- pathways[1:10]
                      }
                      condensed <- paste(pathways, collapse = ',')
                      condensed_list <- c(condensed_list,condensed)
                      module_size <- pathway_total_df[pathway_total_df[,1]==the_mod,7]
                      module_gene_set <- c(module_gene_set,paste(modularized_gene_list[[the_mod]], collapse=','))
                      size_vector <- c(size_vector,module_size[1])
                  } else {
                      condensed_list <- c(condensed_list, 'No Pathways Enriched')
                      module_gene_set <- c(module_gene_set,paste(modularized_gene_list[[the_mod]], collapse=','))
                      size_vector <- c(size_vector, length(modularized_gene_list[[the_mod]]))
                  }
              }
              pathway_total_df <- data.frame('Module'=total_modules,"Module Proteins"=module_gene_set,'# Proteins In Module'=size_vector, 'Functional Pathways'=condensed_list)
              ###################################################################################################################################################
              ###################################################################################################################################################
              ###################################################################################################################################################
              ###################################################################################################################################################
              
              
              #####################################################################################################################################################
              #####################################################################################################################################################
              ################################################### Construct PPI Modularized Output Objects ########################################################
              #####################################################################################################################################################
              #####################################################################################################################################################
              output$DynamicClusterSelectionBox <- renderUI({
                selectInput('ClusterSelect', h5("Select the Cluster You'd Like to Display"),
                            choices = cluster_object_list,
                            selected = 'Cluster 1')
              })
              output$DynamicClusterDisplay <- renderUI({
                alpha <- htmlOutput('ClusterPlotTitle')
                beta <- visNetworkOutput('ClusterPlot')
                gamma <- uiOutput('ClusterBorder')
                fred <- uiOutput('LayoutSelectionPanel')
                delta <- dataTableOutput('ClusterTable')
                epsilon <- dataTableOutput('ClusterCoefficient')
                cluster_content <- list(alpha,beta,gamma,fred,delta,epsilon)
                do.call(tagList, cluster_content)
              })
              output$DynamicModularDisplay <- renderUI({
                alpha3 <- htmlOutput('ModularPlotTitle')
                beta3 <- visNetworkOutput('ModularPlot')
                gamma3 <- uiOutput('ModularBorder')
                delta3 <- dataTableOutput('ModularTable')
                epsilon3 <- dataTableOutput('ModularCoefficient')
                modular_content <- list(alpha3,beta3,gamma3,delta3,epsilon3)
                do.call(tagList, modular_content)
              })
              output$LayoutSelectionPanel <- renderUI({
                selectInput('LayoutSelection', h5("Select a Network Layout Format"),
                            choices=list("Fruchterman Reingold" = 'layout_with_fr',
                                         "Circle" = "layout_in_circle"),
                            selected = "Fruchterman Reingold")
              })
              
              
              observeEvent(input$ClusterSelect, {
                cluster <- input$ClusterSelect
                i <- match(cluster,cluster_object_list)
                network_content <- nodular_dataframe_list[[i]]
                num_genes <- nrow(network_content)
                group_vector1 <- unique(network_content[,'group'])
                num_modules <- length(group_vector1)
                title_1 <- sprintf("Figure 1. Co-Expression Cluster %d: %d Modules Found, %d Constituent Genes", i, num_modules, num_genes)
                css <- sprintf('<p style="font-size:30px">%s </p>', title_1)
                output$ClusterPlotTitle <- renderText(css)
                layout <- reactive({ 
                  input$LayoutSelection
                })
                observeEvent(layout(), {
                  output$ClusterPlot <- renderVisNetwork({
                    if (layout() == 'layout_with_fr'){
                      visNetwork(network_content, edge_frame_list[[i]], height='1400px', width='100%') %>% 
                        visOptions(highlightNearest = TRUE, manipulation=TRUE,selectedBy = "group") %>%
                        visIgraphLayout(layout='layout_with_fr', weights=edge_weight_list[[i]]) 
                    } else if (layout() == 'layout_in_circle') { 
                      visNetwork(network_content, edge_frame_list[[i]], height='1400px', width='100%') %>% 
                        visOptions(highlightNearest = TRUE, manipulation=TRUE,selectedBy = "group") %>%
                        visIgraphLayout(layout='layout_in_circle') 
                    }
                  })
                })
                output$ClusterBorder <- renderUI({
                  addCssClass(class = 'networkplotborder1', selector = 'ClusterPlot')
                })
                visNetwork(network_content, edge_frame_list[[i]], main=title_1 , height='2000px', width='100%') %>% 
                  visOptions(highlightNearest = TRUE, manipulation=TRUE) %>%
                  visIgraphLayout(layout='layout_with_fr', weights=edge_weight_list[[i]]) %>%
                  visSave(file=sprintf("%s/cluster_%d_network.html",directory,i), selfcontained = FALSE)
                
                output$DynamicModuleSelectionBox <- renderUI({
                  selectInput('ModuleSelect', h5("Select the Module You'd Like to Display"),
                              choices = cluster_modules[[i]])
                })
                output$EMAP <- renderUI({
                  alpha <- htmlOutput('ModulePathwayTitle')
                  beta <- uiOutput('ModulePathwayPlot')
                  the_best <- list(alpha,beta)
                  do.call(tagList,the_best)
                })
                output$ModulePathwaySelection <- renderUI({
                  selectInput('ModulePathwaySelect', h5("Select the Pathway Annotation Style"),
                              choices = list('Barplot'='Barplot',
                                             'Circle Plot' = 'Circle Plot',
                                             'Heatmap'='Heatmap',
                                             'Table' = 'Table'))
                })
                modulepathwayplot <- reactive({ 
                  input$ModulePathwaySelect
                })
                observeEvent(input$ModuleSelect, {
                  module <- input$ModuleSelect
                  j <- match(module,cluster_modules[[i]])
                  k <- match(module,modules_used)
                  gene_frame <- final_node_frame[(final_node_frame[,'group']==module),]
                  gene_vector <- as.vector(gene_frame[,'id'])
                  edges <- unique(final_edge_frame[((is.element(final_edge_frame[,'from'], gene_vector)==TRUE) & (is.element(final_edge_frame[,'to'], gene_vector)==TRUE)),])
                  edge_vector <- as.vector(unique(unlist(list(edges[,1],edges[,2]))))
                  gene_frame <- subset(gene_frame,id %in% edge_vector  )
                  edge_weights <- rep(1, nrow(edges))
                  module_title <- sprintf("Figure 3. %s: %d Constituent Genes", module, length(gene_vector))
                  css <- sprintf('<p style="font-size:30px">%s </p>', module_title)
                  output$ModularPlotTitle <- renderText(css)
                  output$ModularPlot <- renderVisNetwork({
                    visNetwork(gene_frame, edges, height='1400px', width='100%') %>% 
                      visOptions(highlightNearest = TRUE, manipulation=TRUE) %>%
                      visIgraphLayout(layout='layout_with_fr', weights=edge_weights) 
                  })
                  
                  observeEvent(modulepathwayplot(),{
                    if (is.null(group_specific_table_list[[k]])==FALSE){
                      if (modulepathwayplot()=='Barplot') {
                        output$ModulePathwayPlot <- renderUI({
                          alpha <- plotOutput('ModulePathwayFigure')
                          the_best <- list(alpha)
                          do.call(tagList,the_best)
                        })
                        this_title <- sprintf('Figure 4a. %s Pathway Barplot', module)
                        css <- sprintf('<p style="font-size:25px">%s </p>', this_title)
                        output$ModulePathwayTitle <- renderText(css)
                        output$ModulePathwayFigure <- renderPlot({
                            modular_pathway_plot_list[[k]]
                        },height=400,width=900)
                      } else if (modulepathwayplot()=='Table') {
                        output$ModulePathwayPlot <- renderUI({
                          alpha <- dataTableOutput('ModulePathwayTable')
                          the_best <- list(alpha)
                          do.call(tagList,the_best)
                        })
                        this_title <- sprintf('Figure 4b. %s Pathway Table', module)
                        css <- sprintf('<p style="font-size:25px">%s </p>', this_title)
                        output$ModulePathwayTitle <- renderText(css)
                        output$ModulePathwayTable <- renderDataTable({
                          DT::datatable(as.data.frame(group_specific_table_list[[k]]), options = list(pageLength=12))
                        })
                      } else if (modulepathwayplot()=='Circle Plot') {
                        output$ModulePathwayPlot <- renderUI({
                          alpha <- imageOutput('ModulePathwayCircle')
                          the_best <- list(alpha)
                          do.call(tagList,the_best)
                        })
                        this_title <- sprintf('Figure 4c. %s Pathway Circle Plot', module)
                        css <- sprintf('<p style="font-size:25px">%s </p>', this_title)
                        output$ModulePathwayTitle <- renderText(css)
                        output$ModulePathwayCircle <- renderPlot({
                          circular.barplot(group_specific_table_list[[k]])
                        },height = 550,width = 700)
                      } else if (modulepathwayplot()=='Heatmap') {
                        output$ModulePathwayPlot <- renderUI({
                          alpha <- imageOutput('ModuleHeatmap')
                          the_best <- list(alpha)
                          do.call(tagList,the_best)
                        })
                        this_title <- sprintf('Figure 4d. %s Pathway Heatmap', module)
                        css <- sprintf('<p style="font-size:25px">%s </p>', this_title)
                        output$ModulePathwayTitle <- renderText(css)
                        output$ModuleHeatmap <- renderImage({
                          outfile <- tempfile(fileext='.png')
                          png(outfile, width=450, height=500)
                          dev.off()
                          list(src = sprintf("%s/%s_heatmap.png",directory,module),
                               contentType = 'image/png',
                               width = 450,
                               height = 500,
                               alt = "This is alternate text")
                        }, deleteFile=FALSE)
                        
                      }
                    } else if (is.null(group_specific_table_list[[k]])==TRUE){
                      output$ModulePathwayPlot <- renderUI({
                        alpha <- imageOutput('NullImage')
                        the_best <- list(alpha)
                        do.call(tagList,the_best)
                      })
                      output$NullImage <- renderImage({
                        outfile <- tempfile(fileext='.png')
                        png(outfile, width=450, height=500)
                        dev.off()
                        list(src = sprintf("%s/JUMPn_Helpers/Null_Objects/null_pathway.png",project_wd),
                             contentType = 'image/png',
                             width = 450,
                             height = 500,
                             alt = "This is alternate text")
                      }, deleteFile=FALSE)
                    }
                    })
                })
                observeEvent(input$ClusterExpressionDisplay, {
                    if (ModeOfAnalysis()=='WGCNA+PPI' || ModeOfAnalysis()=='Independent WGCNA'){
                      if (input$ClusterExpressionDisplay=='Trends'){
                        output$ExpressionFormat <- renderUI({
                          new_main_title <- htmlOutput("NewTrendTitle")
                          new_main_plot <- imageOutput("NewTrendPlot")
                          new_trend_content <- list(new_main_title, new_main_plot)
                          do.call(tagList, new_trend_content)
                        })
                        title2 <- sprintf("Figure 2b. Cluster %s Co-Expression Trend", i)
                        css2 <- sprintf('<p style="font-size:30px">\t%s</p>', title2)
                        output[['NewTrendTitle']] <- renderText(css2)
                        new_trend_file <- sprintf('%s/trend_coexpression_cluster_%d.png', wgcna_directory,i)
                        output$NewTrendPlot <- renderImage({
                          outfile <- tempfile(fileext='.png')
                          png(outfile, width=400, height=500)
                          dev.off()
                          list(src = new_trend_file,
                               contentType = 'image/png',
                               width = 400,
                               height = 500,
                               alt = "This is alternate text")
                        }, deleteFile=FALSE)
                      } else if (input$ClusterExpressionDisplay=='Boxplot') {
                        output$ExpressionFormat <- renderUI({
                          new_main_title <- htmlOutput("NewBoxplotTitle")
                          new_main_plot <- imageOutput("NewBoxplot")
                          new_trend_content <- list(new_main_title, new_main_plot)
                          do.call(tagList, new_trend_content)
                        })
                        title2 <- sprintf("Figure 2a. Cluster %s Boxplot Trend", i)
                        css2 <- sprintf('<p style="font-size:30px">\t%s</p>', title2)
                        output[['NewBoxplotTitle']] <- renderText(css2)
                        new_boxplot_file <- sprintf('%s/small_boxplot_coexpression_cluster_%d.png', wgcna_directory,i)
                        output[['NewBoxplot']] <- renderImage({
                          outfile <- tempfile(fileext='.png')
                          png(outfile, width=400, height=500)
                          dev.off()
                          list(src = new_boxplot_file,
                               contentType = 'image/png',
                               width = 400,
                               height = 500,
                               alt = "This is alternate text")
                        }, deleteFile=FALSE)
                      } else if (input$ClusterExpressionDisplay=='Pathway Barplot') {
                        output$ExpressionFormat <- renderUI({
                          main_title <- htmlOutput("PathwayTitle")
                          main_plot <- plotOutput("PathwayBarPlot")
                          new_trend_content <- list(main_title, main_plot)
                          do.call(tagList, new_trend_content)
                        })
                        title2 <- sprintf("Figure 2c. Cluster %d Annotations", i)
                        css2 <- sprintf('<p style="font-size:30px">\t%s</p>', title2)
                        output[['PathwayTitle']] <- renderText(css2)
                        output[['PathwayBarPlot']] <- renderPlot({
                            cluster_specific_group_plot[[i]]
                        }, height = 500, width=900)
                        
                      } else if (input$ClusterExpressionDisplay=='Pathway Circle Plot') {
                        output$ExpressionFormat <- renderUI({
                          main_title <- htmlOutput("PathwayTitle")
                          main_plot <- plotOutput("PathwayCirclePlot")
                          new_trend_content <- list(main_title, main_plot)
                          do.call(tagList, new_trend_content)
                        })
                        title2 <- sprintf("Figure 2d. Cluster %d Annotations", i)
                        css2 <- sprintf('<p style="font-size:30px">\t%s</p>', title2)
                        output[['PathwayTitle']] <- renderText(css2)
                        output[['PathwayCirclePlot']] <- renderPlot({
                          circular.barplot(cluster_specific_table_list[[i]])
                        }, height = 500, width=800)
                        
                      }
                    } else if (ModeOfAnalysis()=='Independent PPI'){
                        output$ExpressionFormat <- renderUI({
                            new_main_title <- htmlOutput("NewBoxplotTitle")
                            new_main_plot <- imageOutput("NewBoxplot")
                            new_trend_content <- list(new_main_title, new_main_plot)
                            do.call(tagList, new_trend_content)
                        })
                        title2 <- sprintf("Figure 2. Cluster %s Boxplot Trend", i)
                        css2 <- sprintf('<p style="font-size:30px">\t%s</p>', title2)
                        #output[['NewBoxplotTitle']] <- renderText(css2)
                        new_boxplot_file <- 'JUMPn_Helpers/Null_Objects/null_wgcna.png'
                        output[['NewBoxplot']] <- renderImage({
                            outfile <- tempfile(fileext='.png')
                            png(outfile, width=400, height=500)
                            dev.off()
                            list(src = new_boxplot_file,
                                 contentType = 'image/png',
                                 width = 400,
                                 height = 500,
                                 alt = "This is alternate text")
                        }, deleteFile=FALSE)
                    }
                }) 
              })
            incProgress(message="Computing Network Modularity", .1)
            incProgress(message="Creating Modularized Networks", .1)
            group_list <- list()
            lapply(1:length(nodular_dataframe_list), function(i){
              if (!is.null(nodular_dataframe_list[[i]])==TRUE){
                network_content <- nodular_dataframe_list[[i]]
                num_genes <- nrow(network_content)
                group_vector1 <- unique(network_content[,'group'])
                num_modules <- length(group_vector1)
                title_1 <- sprintf("Co-Expression Cluster %d: %d Modules Found, %d Constituent Genes", i, num_modules, num_genes)
                visNetwork(network_content, edge_frame_list[[i]], main=title_1 , height='2000px', width='100%') %>% 
                  visOptions(highlightNearest = TRUE, manipulation=TRUE) %>%
                  visIgraphLayout(layout='layout_with_fr', weights=edge_weight_list[[i]]) %>%
                  visSave(file=sprintf("%s/cluster_%d_network.html",directory,i), selfcontained = FALSE)
              }
            })
            }
            #####################################################################################################################################################
            #####################################################################################################################################################
            #####################################################################################################################################################
            #####################################################################################################################################################
            
            file_path <- sprintf('%s/%s/ComprehensiveSummaryTables.xlsx',project_wd,target_folder)
            #observeEvent(input$downloadData, {
                if (ModeOfAnalysis()=='WGCNA+PPI'){
                    publication_data <- write_xlsx(list("Cluster Genes"=as.data.frame(total_pathway_df),
                                                         "Cluster Enriched Pathways"=as.data.frame(total_cluster_pathway_dataframe),
                                                         "Module Enriched Pathways"=as.data.frame(pathway_total_df)),
                                                   path=file_path)
                    write_xlsx(list("Cluster Genes"=as.data.frame(total_pathway_df),
                                    "Cluster Enriched Pathways"=as.data.frame(total_cluster_pathway_dataframe),
                                    "Module Enriched Pathways"=as.data.frame(pathway_total_df)),
                               path=file_path)
                } else if (ModeOfAnalysis()=='Independent WGCNA'){
                    publication_data <- write_xlsx(list("Cluster Genes"=as.data.frame(total_pathway_df),"Cluster Enriched Pathways"=as.data.frame(total_cluster_pathway_dataframe)),
                                                   path=file_path)
                    write_xlsx(list("Cluster Genes"=as.data.frame(total_pathway_df),"Cluster Enriched Pathways"=as.data.frame(total_cluster_pathway_dataframe)),
                               path=file_path)
                } else if (ModeOfAnalysis()=='Independent PPI'){
                    print(as.data.frame(pathway_total_df))
                    publication_data <- write_xlsx(as.data.frame(pathway_total_df),path=file_path)
                    write_xlsx(as.data.frame(pathway_total_df),path=file_path)
                }
                #successful_download(session)
            #})
            print(list.files(sprintf('%s/%s', project_wd,target_folder)))
            output_directory <- sprintf('%s/%s', project_wd,target_folder)
            
                
            incProgress(message="Program Finished! Go To Network Analysis Page to View Results", .1)
        })
        total_time <- Sys.time()
        # print(initial_time)
        # print(pre_wgcna)
        # print(post_wgcna)
        # print(post_cluster_pathway_analysis)
        # print(post_cluster_pathway_analysis)
        # print(pre_ppi_analysis)
        # print(post_ppi_analysis)
        # print(pre_modular_pathway_analysis)
        # print(post_modular_pathway_analysis)
        # print(total_time)
        # 
        # Total_Run_Time <- total_time-initial_time
        # WGCNA_time <- post_wgcna-pre_wgcna
        # cluster_pathway_time <- post_cluster_pathway_analysis-pre_cluster_pathway_analysis
        # ppi_time <- post_ppi_analysis - pre_ppi_analysis
        # modular_pathway_time <- post_modular_pathway_analysis - pre_modular_pathway_analysis
        # total_pathway_time <- cluster_pathway_time + modular_pathway_time
        # print(Total_Run_Time)
        # print(WGCNA_time)
        # print(ppi_time)
        # print(cluster_pathway_time)
        # print(modular_pathway_time)
        # print(total_pathway_time)
        print(gc())
        
        programFinishedModal(session)
        
        
        if (ModeOfAnalysis()=='WGCNA+PPI'){
            showTab('whichtab', target='WGCNAPage')
            showTab('whichtab', target='PPIPage')
            output$WGCNATitlePage<- renderText({
                'Results Page 1: WGCNA Output'
            })
            output$PPITitlePage<- renderText({
                'Results Page 2: PPI Output'
            })
        } else if (ModeOfAnalysis()=='Independent WGCNA'){
            showTab('whichtab', target='WGCNAPage')
            output$WGCNATitlePage<- renderText({
                'Results Page: WGCNA Output'
            })
        } else if (ModeOfAnalysis()=='Independent PPI'){ 
            showTab('whichtab', target='PPIPage')
            output$PPITitlePage<- renderText({
                'Results Page: PPI Output'
                
            })
        }
        
        observeEvent(input$TakeMeThere,{
            if (ModeOfAnalysis()=='WGCNA+PPI'){
                updateTabsetPanel(session, 'whichtab',selected='WGCNAPage')
                closeSweetAlert()
                ArrivedToResultsModal('WGCNA+PPI',session)
            }else if (ModeOfAnalysis()=='Independent WGCNA'){
                updateTabsetPanel(session, 'whichtab',selected='WGCNAPage')
                closeSweetAlert()
                ArrivedToResultsModal('Independent WGCNA',session)
                observeEvent(input$SubmitQuickPPI,{
                    removeModal()
                    showModal(QuickPPIModal())
                })
            } else if (ModeOfAnalysis()=='Independent PPI'){
                updateTabsetPanel(session, 'whichtab',selected='PPIPage')
                closeSweetAlert()
                ArrivedToResultsModal('Independent PPI',session)
            }
        })
        
        berify <- reactive(input$TotalData)
        print(input$TotalData)
        observeEvent(berify(),{
            if (berify()==TRUE){
                print(berify())
                output$downloadSelectedData1 <- downloadHandler(
                    filename = function() {
                        paste('JUMPn_Output_Data', ".zip", sep = "")
                    },
                    content = function(file) {
                        files2zip <- dir(sprintf('%s/%s',project_wd, target_folder), full.names = TRUE)
                        print(files2zip)
                        zip(zipfile=file, files=files2zip)    
                    }
                )
                successful_download(session)
            } else if (berify()==FALSE){
                dir.create(sprintf('%s/Output_Locus/set_to_be_exported', project_wd)) 
                root <- sprintf('%s/%s',project_wd,target_folder)
                publication <- reactive(input$PublicationData)
                observeEvent(publication(),{
                    if (publication()==TRUE){
                        print(publication())
                        file.rename(sprintf('%s/%s/ComprehensiveSummaryTables.xlsx',project_wd,target_folder), sprintf('%s/Output_Locus/set_to_be_exported/ComprehensiveSummaryTables.xlsx',project_wd ))
                    } else if (publication()==FALSE){
                        print(publication())
                    }
                })
                Fig1a <- reactive(input$Figure1a)
                observeEvent(Fig1a(),{
                    if (Fig1a()==TRUE){
                        file.rename(sprintf('%s/boxplot_coexpression_cluster.png', wgcna_directory), sprintf('%s/Output_Locus/set_to_be_exported/boxplot_coexpression_cluster.png',project_wd ))
                    }
                })
                Fig2a <- reactive(input$Figure2a)
                observeEvent(Fig2a(),{
                    if (Fig2a()==TRUE){
                        file.rename(sprintf('%s/FDR_heatmap.png', wgcna_directory), sprintf('%s/Output_Locus/set_to_be_exported/FDR_heatmap.png',project_wd ))
                    }
                })
                Fig3a <- reactive(input$Figure3a)
                observeEvent(Fig3a(),{
                    if (Fig3a()==TRUE){
                        file.rename(sprintf('%s/trends_coexpression_cluster.png', wgcna_directory), sprintf('%s/Output_Locus/set_to_be_exported/trends_coexpression_cluster.png',project_wd ))
                        
                    }
                })
                Fig4a <- reactive(input$Figure4a)
                Fig5a <- reactive(input$Figure5a)
                observe({
                    if (Fig4a()==TRUE || Fig5a()==TRUE){
                        look_for_expr_files <- as.vector(unlist(list.files(wgcna_directory)))
                        for (file in 1:length(look_for_expr_files)){
                            the_file <- look_for_expr_files[file]
                            extracted <- substr(the_file, nchar(the_file)-20, nchar(the_file))
                            if (extracted == 'ExpressionProfile.pdf'){
                                file.rename(sprintf('%s/%s', wgcna_directory, the_file), sprintf('%s/Output_Locus/set_to_be_exported/%s',project_wd,the_file ))
                            }
                        }
                    }
                })
                output$downloadSelectedData1 <- downloadHandler(
                    filename = function() {
                        paste('JUMPn_Output_Data', ".zip", sep = "")
                    },
                    content = function(file) {

                        files2zip <- dir(sprintf('%s/Output_Locus/set_to_be_exported',project_wd), full.names = TRUE)
                        print(files2zip)
                        zip(zipfile=file, files=(files2zip)) 
                    }
                )
                successful_download(session)
            }
            
        })
        
        
        
        
        
        #}
        #}
    })
    
        
}


# Run the application 
#shinyApp(ui = ui, server = server)

